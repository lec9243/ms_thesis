[1 of 1] Compiling Main             ( test.hs, test.o )

==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 43, types: 24, coercions: 0}

-- RHS size: {terms: 33, types: 18, coercions: 0}
main :: IO ()
[LclIdX, Str=DmdType]
main =
  print
    @ Integer
    GHC.Show.$fShowInteger
    ((\ (@ t_a1Gp)
        ($dNum_a1KS :: Num t_a1Gp)
        ($dOrd_a1KT :: Ord t_a1Gp) ->
        letrec {
          f_a1pn [Occ=LoopBreaker] :: t_a1Gp -> t_a1Gp
          [LclId, Str=DmdType]
          f_a1pn =
            \ (n_aoY :: t_a1Gp) ->
              case > @ t_a1Gp
                     $dOrd_a1KT
                     n_aoY
                     (fromInteger @ t_a1Gp $dNum_a1KS 1)
              of _ [Occ=Dead] {
                False -> fromInteger @ t_a1Gp $dNum_a1KS 1;
                True ->
                  + @ t_a1Gp
                    $dNum_a1KS
                    n_aoY
                    (f_a1pn
                       (- @ t_a1Gp $dNum_a1KS n_aoY (fromInteger @ t_a1Gp $dNum_a1KS 1)))
              }; } in
        f_a1pn)
       @ Integer
       GHC.Num.$fNumInteger
       integer-gmp-1.0.0.1:GHC.Integer.Type.$fOrdInteger
       3)

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 5, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType]
Main.$trModule =
  GHC.Types.Module
    (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Main"#)




==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [Non-opt simplification],
             inline,
             no rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 42, types: 19, coercions: 0}

-- RHS size: {terms: 28, types: 11, coercions: 0}
main :: IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 720 0}]
main =
  print
    @ Integer
    GHC.Show.$fShowInteger
    (letrec {
       f_a1pn [Occ=LoopBreaker] :: Integer -> Integer
       [LclId,
        Arity=1,
        Str=DmdType,
        Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 550 0}]
       f_a1pn =
         \ (n_aoY :: Integer) ->
           case > @ Integer
                  integer-gmp-1.0.0.1:GHC.Integer.Type.$fOrdInteger
                  n_aoY
                  (fromInteger @ Integer GHC.Num.$fNumInteger 1)
           of _ [Occ=Dead] {
             False -> fromInteger @ Integer GHC.Num.$fNumInteger 1;
             True ->
               + @ Integer
                 GHC.Num.$fNumInteger
                 n_aoY
                 (f_a1pn
                    (- @ Integer
                       GHC.Num.$fNumInteger
                       n_aoY
                       (fromInteger @ Integer GHC.Num.$fNumInteger 1)))
           }; } in
     f_a1pn 3)

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s20l :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s20l = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s20m :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s20m = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s20l $trModule_s20m




==================== Tidy Core ====================
Result size of Tidy Core = {terms: 42, types: 19, coercions: 0}

-- RHS size: {terms: 28, types: 11, coercions: 0}
main :: IO ()
[GblId, Str=DmdType]
main =
  print
    @ Integer
    GHC.Show.$fShowInteger
    (letrec {
       f_a1pn [Occ=LoopBreaker] :: Integer -> Integer
       [LclId, Arity=1, Str=DmdType]
       f_a1pn =
         \ (n_aoY :: Integer) ->
           case > @ Integer
                  integer-gmp-1.0.0.1:GHC.Integer.Type.$fOrdInteger
                  n_aoY
                  (fromInteger @ Integer GHC.Num.$fNumInteger 1)
           of _ [Occ=Dead] {
             False -> fromInteger @ Integer GHC.Num.$fNumInteger 1;
             True ->
               + @ Integer
                 GHC.Num.$fNumInteger
                 n_aoY
                 (f_a1pn
                    (- @ Integer
                       GHC.Num.$fNumInteger
                       n_aoY
                       (fromInteger @ Integer GHC.Num.$fNumInteger 1)))
           }; } in
     f_a1pn 3)

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[GblId, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule1_r207 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType]
$trModule1_r207 = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule2_r20p :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType]
$trModule2_r20p = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=DmdType]
Main.$trModule = GHC.Types.Module $trModule1_r207 $trModule2_r20p




==================== CorePrep ====================
Result size of CorePrep = {terms: 64, types: 28, coercions: 0}

-- RHS size: {terms: 46, types: 18, coercions: 0}
sat_s20H :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
sat_s20H =
  letrec {
    f_s20r [Occ=LoopBreaker]
      :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
    [LclId, Arity=1, Str=DmdType, Unf=OtherCon []]
    f_s20r =
      \ (n_s20s :: GHC.Integer.Type.Integer) ->
        let {
          sat_s20z [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_s20z =
            let {
              sat_s20y [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_s20y = GHC.Integer.Type.S# 1# } in
            GHC.Num.fromInteger
              @ GHC.Integer.Type.Integer GHC.Num.$fNumInteger sat_s20y } in
        case GHC.Classes.>
               @ GHC.Integer.Type.Integer
               GHC.Integer.Type.$fOrdInteger
               n_s20s
               sat_s20z
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              sat_s20B [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_s20B = GHC.Integer.Type.S# 1# } in
            GHC.Num.fromInteger
              @ GHC.Integer.Type.Integer GHC.Num.$fNumInteger sat_s20B;
          GHC.Types.True ->
            let {
              sat_s20F [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_s20F =
                let {
                  sat_s20E [Occ=Once] :: GHC.Integer.Type.Integer
                  [LclId, Str=DmdType]
                  sat_s20E =
                    let {
                      sat_s20D [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      sat_s20D =
                        let {
                          sat_s20C [Occ=Once] :: GHC.Integer.Type.Integer
                          [LclId, Str=DmdType]
                          sat_s20C = GHC.Integer.Type.S# 1# } in
                        GHC.Num.fromInteger
                          @ GHC.Integer.Type.Integer GHC.Num.$fNumInteger sat_s20C } in
                    GHC.Num.-
                      @ GHC.Integer.Type.Integer
                      GHC.Num.$fNumInteger
                      n_s20s
                      sat_s20D } in
                f_s20r sat_s20E } in
            GHC.Num.+
              @ GHC.Integer.Type.Integer GHC.Num.$fNumInteger n_s20s sat_s20F
        }; } in
  let {
    sat_s20G [Occ=Once] :: GHC.Integer.Type.Integer
    [LclId, Str=DmdType]
    sat_s20G = GHC.Integer.Type.S# 3# } in
  f_s20r sat_s20G

-- RHS size: {terms: 3, types: 1, coercions: 0}
Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType]
Main.main =
  System.IO.print
    @ GHC.Integer.Type.Integer GHC.Show.$fShowInteger sat_s20H

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule1_r207 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
$trModule1_r207 = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule2_r20p :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
$trModule2_r20p = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
Main.$trModule = GHC.Types.Module $trModule1_r207 $trModule2_r20p



Linking test ...
